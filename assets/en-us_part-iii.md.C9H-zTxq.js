import{_ as e,c as t,o as a,a1 as s}from"./chunks/framework.biRBrEtS.js";const u=JSON.parse('{"title":"PART III: Derived Data","description":"","frontmatter":{},"headers":[],"relativePath":"en-us/part-iii.md","filePath":"en-us/part-iii.md"}'),i={name:"en-us/part-iii.md"},o=s('<h1 id="part-iii-derived-data" tabindex="-1">PART III: Derived Data <a class="header-anchor" href="#part-iii-derived-data" aria-label="Permalink to &quot;PART III: Derived Data&quot;">​</a></h1><p>In Parts <a href="./part-i.html">I</a> and <a href="./part-ii.html">II</a> of this book, we assembled from the ground up all the major consid‐ erations that go into a distributed database, from the layout of data on disk all the way to the limits of distributed consistency in the presence of faults. However, this discussion assumed that there was only one database in the application.</p><p>In reality, data systems are often more complex. In a large application you often need to be able to access and process data in many different ways, and there is no one data‐ base that can satisfy all those different needs simultaneously. Applications thus com‐ monly use a combination of several different datastores, indexes, caches, analytics systems, etc. and implement mechanisms for moving data from one store to another.</p><p>In this final part of the book, we will examine the issues around integrating multiple different data systems, potentially with different data models and optimized for dif‐ ferent access patterns, into one coherent application architecture. This aspect of system-building is often overlooked by vendors who claim that their product can sat‐ isfy all your needs. In reality, integrating disparate systems is one of the most impor‐ tant things that needs to be done in a nontrivial application.</p><h2 id="systems-of-record-and-derived-data" tabindex="-1">Systems of Record and Derived Data <a class="header-anchor" href="#systems-of-record-and-derived-data" aria-label="Permalink to &quot;Systems of Record and Derived Data&quot;">​</a></h2><p>On a high level, systems that store and process data can be grouped into two broad categories:</p><p><em><strong>Systems of record</strong></em></p><p>A system of record, also known as <em>source of truth</em>, holds the authoritative version of your data. When new data comes in, e.g., as user input, it is first written here. Each fact is represented exactly once (the representation is typically <em>normalized</em>). If there is any discrepancy between another system and the system of record, then the value in the system of record is (by definition) the correct one.</p><p><em><strong>Derived data systems</strong></em></p><p>Data in a derived system is the result of taking some existing data from another system and transforming or processing it in some way. If you lose derived data, you can recreate it from the original source. A classic example is a cache: data can be served from the cache if present, but if the cache doesn’t contain what you need, you can fall back to the underlying database. Denormalized values, indexes, and materialized views also fall into this category. In recommendation systems, predictive summary data is often derived from usage logs.</p><p>Technically speaking, derived data is <em>redundant</em>, in the sense that it duplicates exist‐ ing information. However, it is often essential for getting good performance on read queries. It is commonly <em>denormalized</em>. You can derive several different datasets from a single source, enabling you to look at the data from different “points of view.”</p><p>Not all systems make a clear distinction between systems of record and derived data in their architecture, but it’s a very helpful distinction to make, because it clarifies the dataflow through your system: it makes explicit which parts of the system have which inputs and which outputs, and how they depend on each other.</p><p>Most databases, storage engines, and query languages are not inherently either a sys‐ tem of record or a derived system. A database is just a tool: how you use it is up to you. The distinction between system of record and derived data system depends not on the tool, but on how you use it in your application.</p><p>By being clear about which data is derived from which other data, you can bring clarity to an otherwise confusing system architecture. This point will be a running theme throughout this part of the book.</p><h2 id="overview-of-chapters" tabindex="-1">Overview of Chapters <a class="header-anchor" href="#overview-of-chapters" aria-label="Permalink to &quot;Overview of Chapters&quot;">​</a></h2><p>We will start in <a href="./ch10.html">Chapter 10</a> by examining batch-oriented dataflow systems such as MapReduce, and see how they give us good tools and principles for building large- scale data systems. In <a href="./ch11.html">Chapter 11</a> we will take those ideas and apply them to data streams, which allow us to do the same kinds of things with lower delays. <a href="./ch12.html">Chapter 12</a> concludes the book by exploring ideas about how we might use these tools to build reliable, scalable, and maintainable applications in the future.</p>',16),n=[o];function r(d,h,c,l,m,p){return a(),t("div",null,n)}const y=e(i,[["render",r]]);export{u as __pageData,y as default};
