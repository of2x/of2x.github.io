import{_ as r}from"./chunks/figii-1.B6cG2XWi.js";import{_ as t,c as a,o as e,a1 as o}from"./chunks/framework.biRBrEtS.js";const b=JSON.parse('{"title":"第二部分：分散式資料","description":"","frontmatter":{},"headers":[],"relativePath":"zh-tw/part-ii.md","filePath":"zh-tw/part-ii.md"}'),h={name:"zh-tw/part-ii.md"},i=o('<h1 id="第二部分-分散式資料" tabindex="-1">第二部分：分散式資料 <a class="header-anchor" href="#第二部分-分散式資料" aria-label="Permalink to &quot;第二部分：分散式資料&quot;">​</a></h1><blockquote><p>一個成功的技術，現實的優先順序必須高於公關，你可以糊弄別人，但糊弄不了自然規律。</p><p>—— 羅傑斯委員會報告（1986）</p></blockquote><hr><p>在本書的 <a href="./part-i.html">第一部分</a> 中，我們討論了資料系統的各個方面，但僅限於資料儲存在單臺機器上的情況。現在我們到了 <a href="./part-ii.html">第二部分</a>，進入更高的層次，並提出一個問題：如果 <strong>多臺機器</strong> 參與資料的儲存和檢索，會發生什麼？</p><p>你可能會出於各種各樣的原因，希望將資料庫分佈到多臺機器上：</p><ul><li><p>可伸縮性</p><p>如果你的資料量、讀取負載、寫入負載超出單臺機器的處理能力，可以將負載分散到多臺計算機上。</p></li><li><p>容錯 / 高可用性</p><p>如果你的應用需要在單臺機器（或多臺機器，網路或整個資料中心）出現故障的情況下仍然能繼續工作，則可使用多臺機器，以提供冗餘。一臺故障時，另一臺可以接管。</p></li><li><p>延遲</p><p>如果在世界各地都有使用者，你也許會考慮在全球範圍部署多個伺服器，從而每個使用者可以從地理上最近的資料中心獲取服務，避免了等待網路資料包穿越半個世界。</p></li></ul><h2 id="伸縮至更高的載荷" tabindex="-1">伸縮至更高的載荷 <a class="header-anchor" href="#伸縮至更高的載荷" aria-label="Permalink to &quot;伸縮至更高的載荷&quot;">​</a></h2><p>如果你需要的只是伸縮至更高的 <strong>載荷（load）</strong>，最簡單的方法就是購買更強大的機器（有時稱為 <strong>垂直伸縮</strong>，即 vertical scaling，或 <strong>向上伸縮</strong>，即 scale up）。許多處理器，記憶體和磁碟可以在同一個作業系統下相互連線，快速的相互連線允許任意處理器訪問記憶體或磁碟的任意部分。在這種 <strong>共享記憶體架構（shared-memory architecture）</strong> 中，所有的元件都可以看作一臺單獨的機器 [^i]。</p><p>[^i]: 在大型機中，儘管任意處理器都可以訪問記憶體的任意部分，但總有一些記憶體區域與一些處理器更接近（稱為 <strong>非均勻記憶體訪問（nonuniform memory access, NUMA）</strong>【1】）。 為了有效利用這種架構特性，需要對處理進行細分，以便每個處理器主要訪問臨近的記憶體，這意味著即使表面上看起來只有一臺機器在執行，<strong>分割槽（partitioning）</strong> 仍然是必要的。</p><p>共享記憶體方法的問題在於，成本增長速度快於線性增長：一臺有著雙倍處理器數量，雙倍記憶體大小，雙倍磁碟容量的機器，通常成本會遠遠超過原來的兩倍。而且可能因為存在瓶頸，並不足以處理雙倍的載荷。</p><p>共享記憶體架構可以提供有限的容錯能力，高階機器可以使用熱插拔的元件（不關機更換磁碟，記憶體模組，甚至處理器）—— 但它必然囿於單個地理位置的桎梏。</p><p>另一種方法是 <strong>共享磁碟架構（shared-disk architecture）</strong>，它使用多臺具有獨立處理器和記憶體的機器，但將資料儲存在機器之間共享的磁碟陣列上，這些磁碟透過快速網路連線 [^ii]。這種架構用於某些資料倉庫，但競爭和鎖定的開銷限制了共享磁碟方法的可伸縮性【2】。</p><p>[^ii]: 網路附屬儲存（Network Attached Storage, NAS），或 <strong>儲存區網路（Storage Area Network, SAN）</strong></p><h3 id="無共享架構" tabindex="-1">無共享架構 <a class="header-anchor" href="#無共享架構" aria-label="Permalink to &quot;無共享架構&quot;">​</a></h3><p>相比之下，<strong>無共享架構</strong>【3】（shared-nothing architecture，有時被稱為 <strong>水平伸縮</strong>，即 horizontal scaling，或 <strong>向外伸縮</strong>，即 scaling out）已經相當普及。在這種架構中，執行資料庫軟體的每臺機器 / 虛擬機器都稱為 <strong>節點（node）</strong>。每個節點只使用各自的處理器，記憶體和磁碟。節點之間的任何協調，都是在軟體層面使用傳統網路實現的。</p><p>無共享系統不需要使用特殊的硬體，所以你可以用任意機器 —— 比如價效比最好的機器。你也許可以跨多個地理區域分佈資料從而減少使用者延遲，或者在損失一整個資料中心的情況下倖免於難。隨著雲端虛擬機器部署的出現，即使是小公司，現在無需 Google 級別的運維，也可以實現異地分散式架構。</p><p>在這一部分裡，我們將重點放在無共享架構上。它不見得是所有場景的最佳選擇，但它是最需要你謹慎從事的架構。如果你的資料分佈在多個節點上，你需要意識到這樣一個分散式系統中約束和權衡 —— 資料庫並不能魔術般地把這些東西隱藏起來。</p><p>雖然分散式無共享架構有許多優點，但它通常也會給應用帶來額外的複雜度，有時也會限制你可用資料模型的表達力。在某些情況下，一個簡單的單執行緒程式可以比一個擁有超過 100 個 CPU 核的叢集表現得更好【4】。另一方面，無共享系統可以非常強大。接下來的幾章，將詳細討論分散式資料會帶來的問題。</p><h3 id="複製-vs-分割槽" tabindex="-1">複製 vs 分割槽 <a class="header-anchor" href="#複製-vs-分割槽" aria-label="Permalink to &quot;複製 vs 分割槽&quot;">​</a></h3><p>資料分佈在多個節點上有兩種常見的方式：</p><ul><li><p>複製（Replication）</p><p>在幾個不同的節點上儲存資料的相同副本，可能放在不同的位置。 複製提供了冗餘：如果一些節點不可用，剩餘的節點仍然可以提供資料服務。 複製也有助於改善效能。 <a href="./ch5.html">第五章</a> 將討論複製。</p></li><li><p>分割槽 (Partitioning)</p><p>將一個大型資料庫拆分成較小的子集（稱為 <strong>分割槽</strong>，即 partitions），從而不同的分割槽可以指派給不同的 <strong>節點</strong>（nodes，亦稱 <strong>分片</strong>，即 sharding）。 <a href="./ch6.html">第六章</a> 將討論分割槽。</p></li></ul><p>複製和分割槽是不同的機制，但它們經常同時使用。如 <a href="../img/figii-1.png">圖 II-1</a> 所示。</p><p><img src="'+r+'" alt=""></p><p><strong>圖 II-1 一個數據庫切分為兩個分割槽，每個分割槽都有兩個副本</strong></p><p>理解了這些概念，就可以開始討論在分散式系統中需要做出的困難抉擇。<a href="./ch7.html">第七章</a> 將討論 <strong>事務 (Transaction)</strong>，這對於瞭解資料系統中可能出現的各種問題，以及我們可以做些什麼很有幫助。<a href="./ch8.html">第八章</a> 和 <a href="./ch9.html">第九章</a> 將討論分散式系統的根本侷限性。</p><p>在本書的 <a href="./part-iii.html">第三部分</a> 中，將討論如何將多個（可能是分散式的）資料儲存整合為一個更大的系統，以滿足複雜的應用需求。 但首先，我們來聊聊分散式的資料。</p><h2 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to &quot;索引&quot;">​</a></h2><ol start="5"><li><a href="./ch5.html">複製</a></li><li><a href="./ch6.html">分割槽</a></li><li><a href="./ch7.html">事務</a></li><li><a href="./ch8.html">分散式系統的麻煩</a></li><li><a href="./ch9.html">一致性與共識</a></li></ol><h2 id="參考文獻" tabindex="-1">參考文獻 <a class="header-anchor" href="#參考文獻" aria-label="Permalink to &quot;參考文獻&quot;">​</a></h2><ol><li>Ulrich Drepper: “<a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" target="_blank" rel="noreferrer">What Every Programmer Should Know About Memory</a>,” akka‐dia.org, November 21, 2007.</li><li>Ben Stopford: “<a href="http://www.benstopford.com/2009/11/24/understanding-the-shared-nothing-architecture/" target="_blank" rel="noreferrer">Shared Nothing vs. Shared Disk Architectures: An Independent View</a>,” benstopford.com, November 24, 2009.</li><li>Michael Stonebraker: “<a href="http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf" target="_blank" rel="noreferrer">The Case for Shared Nothing</a>,” IEEE Database EngineeringBulletin, volume 9, number 1, pages 4–9, March 1986.</li><li>Frank McSherry, Michael Isard, and Derek G. Murray: “<a href="http://www.frankmcsherry.org/assets/COST.pdf" target="_blank" rel="noreferrer">Scalability! But at What COST?</a>,” at 15th USENIX Workshop on Hot Topics in Operating Systems (HotOS),May 2015.</li></ol><hr><table><thead><tr><th>上一章</th><th>目錄</th><th>下一章</th></tr></thead><tbody><tr><td><a href="./ch4.html">第四章：編碼與演化</a></td><td><a href="./README.html">設計資料密集型應用</a></td><td><a href="./ch5.html">第五章：複製</a></td></tr></tbody></table>',32),n=[i];function l(s,p,c,d,g,m){return e(),a("div",null,n)}const _=t(h,[["render",l]]);export{b as __pageData,_ as default};
