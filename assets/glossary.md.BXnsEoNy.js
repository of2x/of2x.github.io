import{_ as t,c as r,o as p,a1 as l}from"./chunks/framework.biRBrEtS.js";const d=JSON.parse('{"title":"术语表","description":"","frontmatter":{},"headers":[],"relativePath":"glossary.md","filePath":"glossary.md"}'),a={name:"glossary.md"},h=l('<h1 id="术语表" tabindex="-1">术语表 <a class="header-anchor" href="#术语表" aria-label="Permalink to &quot;术语表&quot;">​</a></h1><blockquote><p>请注意，本术语表中的定义简短而简单，旨在传达核心思想，而不是术语的完整细微之处。 有关更多详细信息，请参阅正文中的参考资料。</p></blockquote><ul><li><p><strong>异步（asynchronous）</strong></p><p>不等待某些事情完成（例如，将数据发送到网络中的另一个节点），并且不会假设要花多长时间。请参阅“<a href="./ch5.html#同步复制与异步复制">同步复制与异步复制</a>”、“<a href="./ch8.html#同步网络与异步网络">同步网络与异步网络</a>”以及“<a href="./ch8.html#系统模型与现实">系统模型与现实</a>”。</p></li><li><p><strong>原子（atomic）</strong></p><p>在并发操作的上下文中：描述一个在单个时间点看起来生效的操作，所以另一个并发进程永远不会遇到处于“半完成”状态的操作。另见隔离。</p><p>在事务的上下文中：将一些写入操作分为一组，这组写入要么全部提交成功，要么遇到错误时全部回滚。请参阅“<a href="./ch7.html#原子性">原子性</a>”和“<a href="./ch9.html#原子提交与两阶段提交">原子提交与两阶段提交</a>”。</p></li><li><p><strong>背压（backpressure）</strong></p><p>接收方接收数据速度较慢时，强制降低发送方的数据发送速度。也称为流量控制。请参阅“<a href="./ch11.html#消息传递系统">消息传递系统</a>”。</p></li><li><p><strong>批处理（batch process）</strong></p><p>一种计算，它将一些固定的（通常是大的）数据集作为输入，并将其他一些数据作为输出，而不修改输入。见<a href="./ch10.html">第十章</a>。</p></li><li><p><strong>边界（bounded）</strong></p><p>有一些已知的上限或大小。例如，网络延迟情况（请参阅“<a href="./ch8.html#超时与无穷的延迟">超时与无穷的延迟</a>”）和数据集（请参阅<a href="./ch11.html">第十一章</a>的介绍）。</p></li><li><p><strong>拜占庭故障（Byzantine fault）</strong></p><p>表现异常的节点，这种异常可能以任意方式出现，例如向其他节点发送矛盾或恶意消息。请参阅“<a href="./ch8.html#拜占庭故障">拜占庭故障</a>”。</p></li><li><p><strong>缓存（cache）</strong></p><p>一种组件，通过存储最近使用过的数据，加快未来对相同数据的读取速度。缓存中通常存放部分数据：因此，如果缓存中缺少某些数据，则必须从某些底层较慢的数据存储系统中，获取完整的数据副本。</p></li><li><p><strong>CAP定理（CAP theorem）</strong></p><p>一个被广泛误解的理论结果，在实践中是没有用的。请参阅“<a href="./ch9.html#CAP定理">CAP定理</a>”。</p></li><li><p><strong>因果关系（causality）</strong></p><p>事件之间的依赖关系，当一件事发生在另一件事情之前。例如，后面的事件是对早期事件的回应，或者依赖于更早的事件，或者应该根据先前的事件来理解。请参阅“<a href="./ch5.html#“此前发生”的关系和并发">“此前发生”的关系和并发</a>”和“<a href="./ch5.html#顺序与因果关系">顺序与因果关系</a>”。</p></li><li><p><strong>共识（consensus）</strong></p><p>分布式计算的一个基本问题，就是让几个节点同意某些事情（例如，哪个节点应该是数据库集群的领导者）。问题比乍看起来要困难得多。请参阅“<a href="./ch9.html#容错共识">容错共识</a>”。</p></li><li><p><strong>数据仓库（data warehouse）</strong></p><p>一个数据库，其中来自几个不同的OLTP系统的数据已经被合并和准备用于分析目的。请参阅“<a href="./ch3.html#数据仓库">数据仓库</a>”。</p></li><li><p><strong>声明式（declarative）</strong></p><p>描述某些东西应有的属性，但不知道如何实现它的确切步骤。在查询的上下文中，查询优化器采用声明性查询并决定如何最好地执行它。请参阅“<a href="./ch2.html#数据查询语言">数据查询语言</a>”。</p></li><li><p><strong>非规范化（denormalize）</strong></p><p>为了加速读取，在标准数据集中引入一些冗余或重复数据，通常采用缓存或索引的形式。非规范化的值是一种预先计算的查询结果，像物化视图。请参阅“<a href="./ch7.html#单对象和多对象操作">单对象和多对象操作</a>”和“<a href="./ch11.html#从同一事件日志中派生多个视图">从同一事件日志中派生多个视图</a>”。</p></li><li><p><strong>衍生数据（derived data）</strong></p><p>一种数据集，根据其他数据通过可重复运行的流程创建。必要时，你可以运行该流程再次创建衍生数据。衍生数据通常用于提高特定数据的读取速度。常见的衍生数据有索引、缓存和物化视图。请参阅<a href="./part-iii.html">第三部分</a>的介绍。</p></li><li><p><strong>确定性（deterministic）</strong></p><p>描述一个函数，如果给它相同的输入，则总是产生相同的输出。这意味着它不能依赖于随机数字、时间、网络通信或其他不可预测的事情。</p></li><li><p><strong>分布式（distributed）</strong></p><p>在由网络连接的多个节点上运行。对于部分节点故障，具有容错性：系统的一部分发生故障时，其他部分仍可以正常工作，通常情况下，软件无需了解故障相关的确切情况。请参阅“<a href="./ch8.html#故障与部分失效">故障与部分失效</a>”。</p></li><li><p><strong>持久（durable）</strong></p><p>以某种方式存储数据，即使发生各种故障，也不会丢失数据。请参阅“<a href="./ch7.html#持久性">持久性</a>”。</p></li><li><p><strong>ETL（Extract-Transform-Load）</strong></p><p>提取-转换-加载（Extract-Transform-Load）。从源数据库中提取数据，将其转换为更适合分析查询的形式，并将其加载到数据仓库或批处理系统中的过程。请参阅“<a href="./ch3.html#数据仓库">数据仓库</a>”。</p></li><li><p><strong>故障切换（failover）</strong></p><p>在具有单一领导者的系统中，故障切换是将领导角色从一个节点转移到另一个节点的过程。请参阅“<a href="./ch5.html#处理节点宕机">处理节点宕机</a>”。</p></li><li><p><strong>容错（fault-tolerant）</strong></p><p>如果出现问题（例如，机器崩溃或网络连接失败），可以自动恢复。请参阅“<a href="./ch1.html#可靠性">可靠性</a>”。</p></li><li><p><strong>流量控制（flow control）</strong></p><p>见背压（backpressure）。</p></li><li><p><strong>追随者（follower）</strong></p><p>一种数据副本，仅处理领导者或主库发出的数据变更，不直接接受来自客户端的任何写入。也称为备库、从库、只读副本或热备份。请参阅“<a href="./ch5.html#领导者与追随者">领导者与追随者</a>”。</p></li><li><p><strong>全文检索（full-text search）</strong></p><p>通过任意关键字来搜索文本，通常具有附加特征，例如匹配类似的拼写词或同义词。全文索引是一种支持这种查询的次级索引。请参阅“<a href="./ch3.html#全文搜索和模糊索引">全文搜索和模糊索引</a>”。</p></li><li><p><strong>图（graph）</strong></p><p>一种数据结构，由顶点（可以指向的东西，也称为节点或实体）和边（从一个顶点到另一个顶点的连接，也称为关系或弧）组成。请参阅“<a href="./ch2.html#图数据模型">图数据模型</a>”。</p></li><li><p><strong>散列（hash）</strong></p><p>将输入转换为看起来像随机数值的函数。相同的输入会转换为相同的数值，不同的输入一般会转换为不同的数值，也可能转换为相同数值（也被称为冲突）。请参阅“<a href="./ch6.html#根据键的散列分区">根据键的散列分区</a>”。</p></li><li><p><strong>幂等（idempotent）</strong></p><p>用于描述一种操作可以安全地重试执行，即执行多次的效果和执行一次的效果相同。请参阅“<a href="./ch11.html#幂等性">幂等性</a>”。</p></li><li><p><strong>索引（index）</strong></p><p>一种数据结构。通过索引，你可以根据特定字段的值，在所有数据记录中进行高效检索。请参阅“<a href="./ch3.html#驱动数据库的数据结构">驱动数据库的数据结构</a>”。</p></li><li><p><strong>隔离性（isolation）</strong></p><p>在事务上下文中，用于描述并发执行事务的互相干扰程度。串行运行具有最强的隔离性，不过其它程度的隔离也通常被使用。请参阅“<a href="./ch7.html#隔离性">隔离性</a>”。</p></li><li><p><strong>连接（join）</strong></p><p>汇集有共同点的记录。在一个记录与另一个记录有关（外键，文档参考，图中的边）的情况下最常用，查询需要获取参考所指向的记录。请参阅“<a href="./ch2.html#多对一和多对多的关系">多对一和多对多的关系</a>”和“<a href="./ch10.html#Reduce侧连接与分组">Reduce侧连接与分组</a>”。</p></li><li><p><strong>领导者（leader）</strong></p><p>当数据或服务被复制到多个节点时，领导者是被指定为可以接受数据变更的副本。领导者可以通过某些协议选举产生，也可以由管理员手动选择。领导者也被称为主库。请参阅“<a href="./ch5.html#领导者与追随者">领导者与追随者</a>”。</p></li><li><p><strong>线性化（linearizable）</strong></p><p>表现为系统中只有一份通过原子操作更新的数据副本。请参阅“<a href="./ch9.html#线性一致性">线性一致性</a>”。</p></li><li><p><strong>局部性（locality）</strong></p><p>一种性能优化方式，如果经常在相同的时间请求一些离散数据，把这些数据放到一个位置。请参阅“<a href="./ch2.html#查询的数据局部性">查询的数据局部性</a>”。</p></li><li><p><strong>锁（lock）</strong></p><p>一种保证只有一个线程、节点或事务可以访问的机制，如果其它线程、节点或事务想访问相同元素，则必须等待锁被释放。请参阅“<a href="./ch7.html#两阶段锁定">两阶段锁定</a>”和“<a href="./ch8.html#领导者和锁">领导者和锁</a>”。</p></li><li><p><strong>日志（log）</strong></p><p>日志是一个只能以追加方式写入的文件，用于存放数据。预写式日志用于在存储引擎崩溃时恢复数据（请参阅“<a href="./ch3.html#让B树更可靠">让B树更可靠</a>”）；结构化日志存储引擎使用日志作为它的主要存储格式（请参阅“<a href="./ch3.html#SSTables和LSM树">SSTables和LSM树</a>”）；复制型日志用于把写入从领导者复制到追随者（请参阅“<a href="./ch5.html#领导者与追随者">领导者与追随者</a>”）；事件性日志可以表现为数据流（请参阅“<a href="./ch11.html#分区日志">分区日志</a>”）。</p></li><li><p><strong>物化（materialize）</strong></p><p>急切地计算并写出结果，而不是在请求时计算。请参阅“<a href="./ch3.html#聚合：数据立方体和物化视图">聚合：数据立方体和物化视图</a>”和“<a href="./ch10.html#物化中间状态">物化中间状态</a>”。</p></li><li><p><strong>节点（node）</strong></p><p>计算机上运行的一些软件的实例，通过网络与其他节点通信以完成某项任务。</p></li><li><p><strong>规范化（normalized）</strong></p><p>以没有冗余或重复的方式进行结构化。 在规范化数据库中，当某些数据发生变化时，你只需要在一个地方进行更改，而不是在许多不同的地方复制很多次。 请参阅“<a href="./ch2.html#多对一和多对多的关系">多对一和多对多的关系</a>”。</p></li><li><p><strong>OLAP（Online Analytic Processing）</strong></p><p>在线分析处理。 通过对大量记录进行聚合（例如，计数，总和，平均）来表征的访问模式。 请参阅“<a href="./ch3.html#事务处理还是分析？">事务处理还是分析？</a>”。</p></li><li><p><strong>OLTP（Online Transaction Processing）</strong></p><p>在线事务处理。 访问模式的特点是快速查询，读取或写入少量记录，这些记录通常通过键索引。 请参阅“<a href="./ch3.html#事务处理还是分析？">事务处理还是分析？</a>”。</p></li><li><p><strong>分区（partitioning）</strong></p><p>将单机上的大型数据集或计算结果拆分为较小部分，并将其分布到多台机器上。 也称为分片。见<a href="./ch6.html">第六章</a>。</p></li><li><p><strong>百分位点（percentile）</strong></p><p>通过计算有多少值高于或低于某个阈值来衡量值分布的方法。 例如，某个时间段的第95个百分位响应时间是时间t，则该时间段中，95%的请求完成时间小于t，5%的请求完成时间要比t长。 请参阅“<a href="./ch1.html#描述性能">描述性能</a>”。</p></li><li><p><strong>主键（primary key）</strong></p><p>唯一标识记录的值（通常是数字或字符串）。 在许多应用程序中，主键由系统在创建记录时生成（例如，按顺序或随机）; 它们通常不由用户设置。 另请参阅次级索引。</p></li><li><p><strong>法定人数（quorum）</strong></p><p>在操作完成之前，需要对操作进行投票的最少节点数量。 请参阅“<a href="./ch5.html#读写的法定人数">读写的法定人数</a>”。</p></li><li><p><strong>再平衡（rebalance）</strong></p><p>将数据或服务从一个节点移动到另一个节点以实现负载均衡。 请参阅“<a href="./ch6.html#分区再平衡">分区再平衡</a>”。</p></li><li><p><strong>复制（replication）</strong></p><p>在几个节点（副本）上保留相同数据的副本，以便在某些节点无法访问时，数据仍可访问。请参阅<a href="./ch5.html">第五章</a>。</p></li><li><p><strong>模式（schema）</strong></p><p>一些数据结构的描述，包括其字段和数据类型。 可以在数据生命周期的不同点检查某些数据是否符合模式（请参阅“<a href="./ch2.html#文档模型中的模式灵活性">文档模型中的模式灵活性</a>”），模式可以随时间变化（请参阅<a href="./ch4.html">第四章</a>）。</p></li><li><p><strong>次级索引（secondary index）</strong></p><p>与主要数据存储器一起维护的附加数据结构，使你可以高效地搜索与某种条件相匹配的记录。 请参阅“<a href="./ch3.html#其他索引结构">其他索引结构</a>”和“<a href="./ch6.html#分区与次级索引">分区与次级索引</a>”。</p></li><li><p><strong>可串行化（serializable）</strong></p><p>保证多个并发事务同时执行时，它们的行为与按顺序逐个执行事务相同。 请参阅第七章的“<a href="./ch7.html#可串行化">可串行化</a>”。</p></li><li><p><strong>无共享（shared-nothing）</strong></p><p>与共享内存或共享磁盘架构相比，独立节点（每个节点都有自己的CPU，内存和磁盘）通过传统网络连接。 见<a href="./part-ii.html">第二部分</a>的介绍。</p></li><li><p><strong>偏斜（skew）</strong></p><p>各分区负载不平衡，例如某些分区有大量请求或数据，而其他分区则少得多。也被称为热点。请参阅“<a href="./ch6.html#负载偏斜和热点消除">负载偏斜和热点消除</a>”和“<a href="./ch10.html#处理偏斜">处理偏斜</a>”。</p><p>时间线异常导致事件以不期望的顺序出现。 请参阅“<a href="./ch7.html#快照隔离和可重复读">快照隔离和可重复读</a>”中的关于读取偏差的讨论，“<a href="./ch7.html#写入偏差与幻读">写入偏差与幻读</a>”中的写入偏差以及“<a href="./ch8.html#有序事件的时间戳">有序事件的时间戳</a>”中的时钟偏斜。</p></li><li><p><strong>脑裂（split brain）</strong></p><p>两个节点同时认为自己是领导者的情况，这种情况可能违反系统担保。 请参阅“<a href="./ch5.html#处理节点宕机">处理节点宕机</a>”和“<a href="./ch8.html#真相由多数所定义">真相由多数所定义</a>”。</p></li><li><p><strong>存储过程（stored procedure）</strong></p><p>一种对事务逻辑进行编码的方式，它可以完全在数据库服务器上执行，事务执行期间无需与客户端通信。 请参阅“<a href="./ch7.html#真的串行执行">真的串行执行</a>”。</p></li><li><p><strong>流处理（stream process）</strong></p><p>持续运行的计算。可以持续接收事件流作为输入，并得出一些输出。 见<a href="./ch11.html">第十一章</a>。</p></li><li><p><strong>同步（synchronous）</strong></p><p>异步的反义词。</p></li><li><p><strong>记录系统（system of record）</strong></p><p>一个保存主要权威版本数据的系统，也被称为真相的来源。首先在这里写入数据变更，其他数据集可以从记录系统衍生。 请参阅<a href="./part-iii.html">第三部分</a>的介绍。</p></li><li><p><strong>超时（timeout）</strong></p><p>检测故障的最简单方法之一，即在一段时间内观察是否缺乏响应。 但是，不可能知道超时是由于远程节点的问题还是网络中的问题造成的。 请参阅“<a href="./ch8.html#超时与无穷的延迟">超时与无穷的延迟</a>”。</p></li><li><p><strong>全序（total order）</strong></p><p>一种比较事物的方法（例如时间戳），可以让你总是说出两件事中哪一件更大，哪件更小。 总的来说，有些东西是无法比拟的（不能说哪个更大或更小）的顺序称为偏序。 请参阅“<a href="./ch9.html#因果顺序不是全序的">因果顺序不是全序的</a>”。</p></li><li><p><strong>事务（transaction）</strong></p><p>为了简化错误处理和并发问题，将几个读写操作分组到一个逻辑单元中。 见<a href="./ch7.html">第七章</a>。</p></li><li><p><strong>两阶段提交（2PC, two-phase commit）</strong></p><p>一种确保多个数据库节点全部提交或全部中止事务的算法。 请参阅“<a href="./ch9.html#原子提交与两阶段提交">原子提交与两阶段提交</a>”。</p></li><li><p><strong>两阶段锁定（2PL, two-phase locking）</strong></p><p>一种用于实现可串行化隔离的算法，该算法通过事务获取对其读取或写入的所有数据的锁，直到事务结束。 请参阅“<a href="./ch7.html#两阶段锁定">两阶段锁定</a>”。</p></li><li><p><strong>无边界（unbounded）</strong></p><p>没有任何已知的上限或大小。 反义词是边界（bounded）。</p></li></ul>',3),o=[h];function s(i,n,e,g,c,m){return p(),r("div",null,o)}const u=t(a,[["render",s]]);export{d as __pageData,u as default};
